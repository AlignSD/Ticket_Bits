pragma solidity 0.6.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// Ownable is for implimenting ownership in your contracts
contract Ticket is Ownable, ERC721 {

    //Event Contract address
    address public eventAddress;

    // Ticket Information
    struct TicketInfo {
        uint256 eventId;
        bool redeemed;
    }

    //All ticket is TicketInfo[]
    // Mapping uint256 => TicketInfo
    TicketInfo[] public tickets;

    //Mapping from owner to list of owned token IDs
    mapping(address => uint256[]) internal ownedTokens;

    // Mapping from token ID to index of the owner tokens list
    mapping(uint256 => uint256) internal ownedTokensIndex;

    //Throws event if not called by the Event contract.
    modifier verifyEventContract() {
        require(msg.sender == eventAddress, "Sender must be Event contract");
        _;
    }

    constructor(address _eventAddress) public {
        eventAddress = _eventAddress;
    }

    // Updates the Event contract address
    // _eventAddress is the updated Event address
    // onlyOwner throws if called by any account other than the owner
    function updateEventAddress(address _eventAddress) external onlyOwner {
        eventAddress = _eventAddress;
    }

    // Validates the ticket by address and event ID. Each ticket is given an SHA3 (Secure Hash Algorithm 3) signature (ticketID + one-time code)
    function checkValidation (uint256 eventId, uint ticketId, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public view returns (uint8) {
        // Check if ticket exist by matching ticket ID's to array indices
        if (ticketId >= tickets.length) return 2;

        // Check if the provided address is from the address that owns the ticket
        // if (recovery(msgHash, v, r, s) != tokenOwner[ticketId]) return 3;

        // Verify the ticket bleongs to the event
        if (tickets[ticketId].eventId != eventId) return 4;

        return 5;
    }

    // Checks that ticket exists and hasn't been redeemed. Called by only the Event Contract
    function checkRedeemedStatus(uint256 eventId, uint256 ticketId, bytes32 msgHash, uint v, bytes32 r, bytes32 s) public view returns (uint8) {
        // Repeats Ticket exists check, but is important for the redeemed ticket check.
        if (ticketId >= tickets.length) return 2;

        if (tickets[ticketId].redeemed) return 1;

        return checkValidation(eventId, ticketId, msgHash, v, r, s);
    }

    // Validates a signed message hash with given v, r, c for ecrecover
    // private: only visible in the current contract
    // pure for functions: Disallows modifications or access of state
    function recovery(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) private pure returns (address) {
        // The sign method calculates an Ethereum specific signature with: sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))). By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.
        bytes memory prefix = "\x19Ethereum Signed Message:\n32";
        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, msgHash));
        return ecrecover(prefixedHash, v, r, s);
    }

    // Redeem tickets by ID. Only called when authorization (checkValidation() and checkRedeemedStatus()) happens
    // external: only visible externally (only for functions) -i.e. can only be message-called (via this.func)
    function redeem(uint256 ticketId, uint256 eventId) external verifyEventContract {
        require (ticketId < tickets.length, "This ticket doesn't exist");
        require (tickets[ticketId].eventId == eventId, "Ticket is for a different event");

        tickets[ticketId].redeemed = true;
    }

    // Purchase a new ticket from an event. Called by only contract.
    // buyer is the address of the new ticket owner
    function purchaseTicket(address buyer, uint256 eventId) external verifyEventContract returns (uint256) {
        uint256 id = tickets.push(TicketInfo(eventId, false)) - 1;
        _safeMint(buyer, id);

        return id;
    }

    //Gets the tokens from requested owner
    // _owner address owning the tokens list
    // uint256[] array of token IDs owned by the requested address
    //public: visible externally and internally (creates a getter function for storage/state variables)
    //view for functions: Disallows modification of state.
  
    // function requestedOwnerToken (address _owner) public view returns (tokenOwner) {
    //     return ownedTokens[_owner];
    // }

    // //Gets the token ID at a given index of the tokens list of the requested owner
    // // _owner address owning the tokens list to be accessed
    // // _index uint256 representing the index to be accessed of the requested tokens list
    // function tokenOfOwnerByIndex(address _owner, uint256 _index) public view  returns (uint256) {
    //     require(_index < balanceOf(_owner), "Token index out of owners token list bounds");

    //     // unit256 token ID at the given index of the tokens list owned by the requested address
    //     return ownedTokens[_owner][_index];
    // }

    // // Internal function to add a token ID to the list of a given address
    // // internal: only visible internally
    // // _to address representing the new owner of the given token ID
    // // _tokenId uint256 ID of the token to be added to the tokens list of the given address
    //     function addTokenTo(address _to, uint256 _tokenId) internal {
    //     super.addTokenTo(_to, _tokenId);
    //     uint256 length = ownedTokens[_to].length;
    //     ownedTokens[_to].push(_tokenId);
    //     ownedTokensIndex[_tokenId] = length;
    // }

    // // Internal function to remove a token ID from the list of a given address
    // // _from address representing the previous owner of the given token ID
    // // _tokenId uint256 ID of the token to be removed from the tokens list of the given address
    //     function removeTokenFrom(address _from, uint256 _tokenId) internal {
    //     super.removeTokenFrom(_from, _tokenId);

    //     uint256 tokenIndex = ownedTokensIndex[_tokenId];
    //     uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);
    //     uint256 lastToken = ownedTokens[_from][lastTokenIndex];

    //     ownedTokens[_from][tokenIndex] = lastToken;
    //     ownedTokens[_from][lastTokenIndex] = 0;
    //     // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to
    //     // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping
    //     // the lastToken to the first position, and then dropping the element placed in the last position of the list

    //     ownedTokens[_from].length--;
    //     ownedTokensIndex[_tokenId] = 0;
    //     ownedTokensIndex[lastToken] = tokenIndex;
    // }

}